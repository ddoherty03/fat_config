# FatConfig

~FatConfig~ eliminates the tedium of reading configuration files and the
environment to populate a Hash of configuration settings.  You need only
define a ~FatConfig::Reader~ and you can call its ~#read~ method to look for,
read, translate, and merge any config files into a single Hash that
encapsulates all the files in the proper priority.  It can be set to read
~YAML~, ~TOML~, ~JSON~, or ~INI~ config files.

* Installation

Install the gem and add to the application's Gemfile by executing:

#+begin_src sh
  bundle add fat_config
#+end_src

If bundler is not being used to manage dependencies, install the gem by executing:

#+begin_src sh
  gem install fat_config
#+end_src

* Usage:

#+begin_src ruby
  require 'fat_config'

  reader = FatConfig::Reader.new('myapp')
  config = reader.read
#+end_src

The ~reader.read~ method will parse the config files (by default assumed to be
YAML files), config environment variable, and optional command-line parameters
and return the composite config as a Hash.

** Following XDG Standards
By default, ~FatConfig::Reader#read~ follows the [[https://specifications.freedesktop.org/basedir-spec/latest/][XDG Desktop Standards]],
reading configuration settings for a hypothetical application called ~myapp~
from the following locations, from lowest priority to highest:

1. If the environment variable ~MYAPP_SYS_CONFIG~ is set to the name of a
   file, it will look in that file for any system-level config file.
2. If the environment variable ~MYAPP_SYS_CONFIG~ is NOT set, it will read any
   system-level config file from ~/etc/xdg/myapp~ or, if the ~XDG_CONFIG_DIRS~
   environment variable is set to a list of colon-separated directories, it
   will look in each of those instead of ~/etc/xdg~ for config directories
   called ~myapp~.  If more than one ~XDG_CONFIG_DIRS~ is given, they are
   treated as listed in order of precedence, so the first-listed directory
   will be given priority over later ones.  All such directories will be read,
   and any config file found will be merged into the resulting Hash, but they
   will be visited in reverse order so that the first-named directories
   override the earlier ones.
3. If the environment variable ~MYAPP_CONFIG~ is set to a file name, it will
   look in that file any user-level config file.
4. If the environment variable ~MYAPP_CONFIG~ is NOT set, it will read any
   user-level config file from ~$HOME/.config/myapp~ or, if the
   ~XDG_CONFIG_HOME~ environment variable is set to an alternative directory,
   it will look ~XDG_CONFIG_HOME/.config~ for a config directory called
   'myapp'.  Note that in this case, ~XDG_CONFIG_HOME~ is intended to contain
   the name of a single directory, not a list of directories as with the
   system-level config files.
5. It will then merge in any options set in the environment variable
   ~MYAPP_OPTIONS~, overriding any conflicting settings gotten from reading
   the system- and user-level file.  It will interpret the String from the
   environment variable as discussed below in [[*Parsing Environment and Command Line Strings][Parsing Environment and Command
   Line Strings]].
6. Finally, it will merge in any options given in the optional ~command_line:~
   named parameter to the ~#read~ method.  That parameter can either be a
   ~Hash~ or a ~String~.  If it is a ~String~, it is interpreted the same way
   as the environment variable ~MYAPP_OPTIONS~ as explained below in [[*Parsing Environment and Command Line Strings][Parsing
   Environment and Command Line Strings]]; if it is a ~Hash~, it is used
   directly and merged into the hash returned from the prior methods.

** Following Classic UNIX Standards
With the optional ~:xdg~ keyword parameter to ~FatConfig::Reader#read~ set to
~false~, it will follow "classic" UNIX config file conventions.  There is no
"standard" here, but there are some conventions, and the closest thing I can
find to describe the conventions is this from the [[https://refspecs.linuxfoundation.org/FHS_3.0/fhs/ch03s08.html#homeReferences][UNIX File Hierarchy Standard]]
website:

#+begin_quote
 User specific configuration files for applications are stored in the user's
 home directory in a file that starts with the '.' character (a "dot
 file"). If an application needs to create more than one dot file then they
 should be placed in a subdirectory with a name starting with a '.' character,
 (a "dot directory"). In this case the configuration files should not start
 with the '.' character.
#+end_quote

~FatConfig~'s implementation of this suggestion are as follows for a
hypothetical application called ~myapp~:

1. If the environment variable ~MYAPP_SYS_CONFIG~ is set to a file name, it
   will look in that file for any system-level config file.
2. If the environment variable ~MYAPP_SYS_CONFIG~ is NOT set, then either
   - if the file ~/etc/my_app~ exists and is readable, it is considered the
     system-wide config file for ~my_app~, or
   - if the file ~/etc/my_apprc~ exists and is readable, it is considered the
     system-wide config file for ~my_app~, or
   - if the /directory/ ~/etc/my_app~ exists, the first file named ~config~,
     ~config.yml~, ~config.yaml~ (this assumes the default YAML style, the
     extensions looked for will be adjusted for other styles) ,
     ~myapp.config~, or ~myapp.cfg~ that is readable will be considered the
     system-wide config file for ~my_app~
3. If the environment variable ~MYAPP_CONFIG~ is set to a file name, it will
   look in that file for any user-level config file.
4. If the environment variable ~MYAPP_CONFIG~ is NOT set, then either,
   - if the file, =~/.my_app= or =~/.my_apprc~= exist and are readable, that
     file is used as the user-level config file,
   - otherwise, if the directory =~/.my_app/= exists, the first file in that
     directory named ~config~, ~config.yml~, ~config.yaml~, ~myapp.config~, or
     ~myapp.cfg~ that is readable will be considered the user-level config
     file for ~my_app~
5. It will then merge in any options set in the environment variable
   ~MYAPP_OPTIONS~, overriding any conflicting settings gotten from reading
   the system- and user-level file.  It will interpret the environment setting
   as explained below in [[*Parsing Environment and Command Line Strings][Parsing Environment and Command Line Strings]].
6. Finally, it will merge in any options given in the optional ~command_line:~
   named parameter to the ~#read~ method.  That parameter can either be a
   ~Hash~ or a ~String~.  If it is a ~String~, it will interpret the string as
   explained below in [[*Parsing Environment and Command Line Strings][Parsing Environment and Command Line Strings]]; if it is a
   ~Hash~, it is used directly and merged into the hash returned from the
   prior methods.

** Available Config File Styles
~FatConfig::Reader.new~ takes the optional keyword argument, ~:style~, to
indicate what style to use for config files.  It can be one of:

- ~yaml~ :: See [[https://yaml.org/spec/1.2.2/][YAML Specs]],
- ~toml~ :: See [[https://toml.io/en/][TOML Specs]],
- ~json~ :: See [[https://datatracker.ietf.org/doc/html/rfc8259][JSON Specs]], or
- ~ini~ :: See [[https://en.wikipedia.org/wiki/INI_file][INI File on Wikipedia]]

By default, the style is ~yaml~.  Note that the style only pertains to the
syntax of on-disk configuration files.  Configuration can also be set by an
environment variable, ~MYAPP_OPTIONS~ and by a command-line string optionally
provided to the ~#read~ method.  Those are simple parsers that parse strings
of option settings as explained below.  See, [[*Parsing Environment and Command Line Strings][Parsing Environment and Command
Line Strings]].

** Hash Keys
The returned Hash will have symbols as keys, using the names given in the
config files, except that they will have any hyphens converted to the
underscore.  Thus the config setting "page-width: 6.5in" in a config file will
result in a Hash entry of ~{ page_width: '6.5in' }~.

** Hash Values
Whether the values of the returned Hash will be 'deserialized' into a Ruby
object is controlled by the style of the configuration files.  For example,
the ~:yaml~ style deserializes the following types:

*** YAML

  - TrueClass (the string 'true' of whatever case)
  - FalseClass (the string 'false' of whatever case)
  - NilClass (when no value given)
  - Integer (when it looks like an whole number)
  - Float (when it looks like an decimal number)
  - String (if not one of the other classes or if enclosed in single- or double-quotes)
  - Array (when sub-elements introduced with '-', each typed by these rules)
  - Hash, (when sub-elements introduced with 'key:', each typed by these rules) and,
  - Date, DateTime, and Time, which FatConfig adds to the foregoing default
    types deserialized by the default YAML library.

*** TOML

  - TrueClass (exactly the string 'true')
  - FalseClass (exactly the string 'false')
  - Integer (when it looks like an whole number or 0x... or 0o... hex or octal)
  - Float (when it looks like an decimal number)
  - String (only if enclosed in single- or double-quotes)
  - Array (when sub-elements enclosed in [...], each typed by these rules)
  - Hash, ([hash-key] followed by sub-elements, each typed by these rules) and,
  - Date and Time, when given in ISO form YYYY-MM-DD or YYYY-MM-DDThh:mm:ss

*** JSON

  - TrueClass (exactly the string 'true')
  - FalseClass (exactly the string 'false')
  - Integer (when it looks like an decimal whole number, but NO provision hex
    or octal)
  - Float (when it looks like an decimal number)
  - String (only if enclosed in single- or double-quotes)
  - Array (when sub-elements enclosed in [...], each typed by these rules)
  - Hash, (when sub-elements enclosed in {...}, each typed by these rules) and,
  - Date and Time, NOT deserialized, returns a parse error

*** INI

  - TrueClass (exactly the string 'true')
  - FalseClass (exactly the string 'false')
  - Integer (when it looks like an whole number or 0x... or 0o... hex or octal)
  - Float (when it looks like an decimal number)
  - String (anything else)
  - Array NOT deserialized, returned as a String
  - Hash, NOT deserialized, returned as a String
  - Date and Time, NOT deserialized, returned as a String

** Creating a Reader
When creating a ~Reader~, the ~#new~ method takes a mandatory argument that
specifies the name of the application for which configuration files are to be
sought.  It also takes a few optional keyword arguments:

- ~style:~ specify a style for the config files other than YAML, the choices
  are ~yaml~, ~toml~, ~json~, and ~ini~.  This can be given either as a String
  or Symbol in upper or lower case.
- ~xdg:~ either ~true~, to follow the XDG standard for where to find config
  files, or ~false~, to follow classic UNIX conventions.
- ~root_prefix:~, to locate the root of the file system somewhere other than
  ~/~.  This is probably only useful in testing ~FatConfig~.

#+begin_src ruby
  require 'fat_config'

  reader1 = FatConfig.new('labrat')  # Use XDG and YAML
  reader2 = FatConfig.new('labrat', style: 'toml')  # Use XDG and TOML
  reader3 = FatConfig.new('labrat', style: 'ini', xdg: false)  # Use classic UNIX and INI style
#+end_src

** Calling the ~#read~ method on a ~Reader~
Once a ~Reader~ is created, you can get the completely merged configuration as
a Hash by calling ~Reader#read~.  The ~read~ method can take several
parameter:

- ~alternative base~ :: as the first positional parameter, you can give an
  alternative base name to use for the config files other than the app_name
  given in the ~Reader.new~ constructor.  This is useful for applications that
  may want to have more than one set of configuration files.  If given, this
  name only affects the base names of the config files, not the directory in
  which they are to be sought: those always use the app name.
- ~command_line:~ :: if you want a command-line to override config values, you
  can supply one as either a String or a Hash to the ~command_line:~ keyword
  parameter.  See below for how a String is parsed.
- ~verbose:~ :: if you set ~verbose:~ true as a keyword argument, the ~read~
  method will report details of how the configuration was built on ~$stderr~.

  #+begin_src ruby
    require 'fat_config'

    reader = FatConfig::Reader.new('labrat')
    reader.read  # YAML configs with basename 'labrat'; XDG conventions

    # Now read another config set in directories named 'labrat' but with base
    # names of 'labeldb'.  Overrride any setting named fog_psi with command-line
    # value, and report config build on $stderr.
    reader.read('labeldb', command_line: "--fog-psi=3.41mm", verbose: true)

    # Similar with a Hash for the command-line
    cl = { fog_psi: '3.41mm' }
    reader.read('labeldb', command_line: cl, verbose: true)
  #+end_src

** Parsing Environment and Command Line Strings
The highest priority configs are those contained in the environment variable
or in any ~command-line:~ key-word parameter given to the ~#read~ method.  In
the case of the environment variable, the setting is always a String read from
the environment.

The ~command_line:~ key-word parameter can be set to either a String or a
Hash.  When a Hash is provided, it is used unaltered as a config hash.  When a
String is provided (and in the case of the environment variable), the string
should be something like this:

#+begin_example
--hello-thing='hello, world' --gb=goodbye world --doit --the_num=3.14159 --the-date=2024-11-27 --no-bueno --~junk
#+end_example

And it is parsed into this Hash:

#+begin_src ruby
  {
    :hello_thing=>"hello, world",
   :gb=>"goodbye",
   :doit=>true,
   :the_num=>"3.14159",
   :the_date=>"2024-11-27",
   :bueno=>false,
   :junk=>false
  }
#+end_src

Here are the parsing rules:

1. A config element is either an "option," of the form
   "--<option-name>=<value>" or a "flag" of the form "--<flag-name>",
   everything else is ignored.
2. All option values are returned as String's and are not deserialized into
   Ruby objects,
3. All flags are returned as a boolean ~true~ or ~false~.  If the flag name
   starts with 'no', 'no-', 'no_', '!', or '~', it is set to =false= and the
   option name has the negating prefix stripped; otherwise, it is set to
   =true=.
4. These rules apply regardless of style being used for config files.

* Development

After checking out the repo, run `bin/setup` to install dependencies. Then,
run `rake spec` to run the tests. You can also run `bin/console` for an
interactive prompt that will allow you to experiment.

To install this gem onto your local machine, run `bundle exec rake
install`. To release a new version, update the version number in `version.rb`,
and then run `bundle exec rake release`, which will create a git tag for the
version, push git commits and the created tag, and push the `.gem` file to
[[https://rubygems.org][rubygems.org]].

* Contributing

Bug reports and pull requests are welcome on GitHub at
https://github.com/ddoherty03/fat_config.

* License

The gem is available as open source under the terms of the [[https://opensource.org/licenses/MIT][MIT License]].
